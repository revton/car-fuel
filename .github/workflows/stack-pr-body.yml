name: stack-pr-body

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body with Stack section
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.setFailed('No pull_request in context');
              return;
            }

            async function getOpenPRs(){
              const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
              return prs.map(pr => ({ number: pr.number, title: pr.title, head: pr.head.ref, base: pr.base.ref }));
            }

            function computeRelations(prs, current){
              const byHead = new Map(prs.map(p => [p.head, p]));
              const children = prs.filter(p => p.base === current.head);
              const parent = byHead.get(current.base) || null;
              return { parent, children };
            }

            function buildChain(prs, current){
              const byHead = new Map(prs.map(p => [p.head, p]));
              const byBase = prs.reduce((m,p)=>{ if(!m.has(p.base)) m.set(p.base, []); m.get(p.base).push(p); return m; }, new Map());
              // climb to root
              let root = current;
              while (byHead.get(root.base)) { root = byHead.get(root.base); }
              // descend picking first child to form a linear path
              const path = [root];
              let cursor = root;
              const guard = new Set([cursor.number]);
              while (true){
                const kids = byBase.get(cursor.head) || [];
                if (kids.length === 0) break;
                const next = kids[0];
                if (guard.has(next.number)) break;
                guard.add(next.number);
                path.push(next);
                cursor = next;
              }
              return path.map(p => `#${p.number}`).join(' â†’ ');
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const current = { number: pr.number, title: pr.title, head: pr.head.ref, base: pr.base.ref };
            const prs = await getOpenPRs();
            const { parent, children } = computeRelations(prs, current);
            const parentStr = parent ? `#${parent.number}` : current.base;
            const nextStr = children.length ? children.map(c => `#${c.number}`).join(', ') : '(topo)';
            const chainStr = buildChain(prs, current);

            const begin = '<!-- stack-section:begin -->';
            const end = '<!-- stack-section:end -->';

            let body = pr.body || '';
            // Strip existing section by markers
            const beginIdx = body.indexOf(begin);
            const endIdx = body.indexOf(end);
            if (beginIdx !== -1 && endIdx !== -1 && endIdx > beginIdx){
              body = body.slice(0, beginIdx) + body.slice(endIdx + end.length);
            } else {
              // fallback: naive removal by '## Stack' header until next '---' or EOF
              body = body.replace(/\n?## Stack[\s\S]*?(\n---\n|$)/, '\n');
            }

            const section = `${begin}\n## Stack\n- Parent: ${parentStr}\n- Next: ${nextStr}\n- Cadeia: ${chainStr}\n${end}`;
            const newBody = `${section}\n\n${body.trim()}`.trim() + '\n';

            if (newBody !== (pr.body || '')){
              await github.rest.issues.update({ owner, repo, issue_number: prNumber, body: newBody });
            }
