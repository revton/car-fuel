name: stack-pr-body

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
  workflow_dispatch:
  push:
    branches: [main]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body with Stack section
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ev = context.eventName || (process.env['GITHUB_EVENT_NAME'] || '');
            if (ev !== 'pull_request' || !context.payload.pull_request) {
              core.notice('Not a pull_request event, skipping stack-pr-body.');
              return;
            }
            const prNumber = context.payload.pull_request.number;

            async function getOpenPRs(){
              const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
              return prs.map(pr => ({
                number: pr.number,
                title: pr.title,
                head: pr.head.ref,
                headRepo: pr.head.repo?.full_name || `${owner}/${repo}`,
                base: pr.base.ref,
                baseRepo: pr.base.repo?.full_name || `${owner}/${repo}`,
              }));
            }

            function headKey(p){ return `${p.headRepo}:${p.head}`; }
            function baseKey(p){ return `${p.baseRepo}:${p.base}`; }

            function computeRelations(prs, current){
              const byHead = new Map(prs.map(p => [headKey(p), p]));
              const parentKey = `${owner}/${repo}:${current.base}`;
              const parent = byHead.get(parentKey) || null;
              const wantChildBase = `${owner}/${repo}:${current.head}`;
              const children = prs
                .filter(p => baseKey(p) === wantChildBase)
                .sort((a,b)=>a.number-b.number);
              return { parent, children };
            }

            function buildChain(prs, current){
              const byHead = new Map(prs.map(p => [headKey(p), p]));
              const byBase = prs.reduce((m,p)=>{
                const k = baseKey(p);
                if(!m.has(k)) m.set(k, []);
                m.get(k).push(p);
                return m;
              }, new Map());
              // climb to root within this repo
              let root = current;
              while (byHead.get(`${owner}/${repo}:${root.base}`)) {
                root = byHead.get(`${owner}/${repo}:${root.base}`);
              }
              // descend picking smallest PR number child deterministically
              const path = [root];
              let cursor = root;
              const guard = new Set([cursor.number]);
              while (true){
                const kids = (byBase.get(`${owner}/${repo}:${cursor.head}`) || []).slice().sort((a,b)=>a.number-b.number);
                if (kids.length === 0) break;
                const next = kids[0];
                if (guard.has(next.number)) break;
                guard.add(next.number);
                path.push(next);
                cursor = next;
              }
              return path.map(p => `#${p.number}`).join(' -> ');
            }

            function extractIssueNumbers(pr, rawBody){
              const numbers = new Set();
              const ref = pr.head.ref || '';
              const title = pr.title || '';
              const body = rawBody || '';

              // 1) Numbers in branch name (e.g., adr/129-backend-stack -> 129)
              //    Ignore internal ghstack branches (gh/<user>/<id>/head)
              if (!ref.startsWith('gh/')) {
                const branchMatches = ref.match(/\b(\d{1,5})\b/g) || [];
                for (const raw of branchMatches){
                  const n = parseInt(raw, 10);
                  if (!Number.isNaN(n)) numbers.add(n);
                }
              }

              // 2) Explicit patterns in title/body (Closes #123, Fixes #123, Resolves #123)
              const patterns = [
                /Closes\s*#(\d+)/ig,
                /Fixes\s*#(\d+)/ig,
                /Resolves\s*#(\d+)/ig,
              ];

              function addFrom(text){
                for (const re of patterns){
                  let m;
                  while ((m = re.exec(text)) !== null){
                    const n = parseInt(m[1], 10);
                    if (!Number.isNaN(n)) numbers.add(n);
                  }
                }
              }

              addFrom(title);
              addFrom(body);

              return Array.from(numbers).sort((a,b)=>a-b);
            }

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const current = { number: pr.number, title: pr.title, head: pr.head.ref, base: pr.base.ref };
            const prs = await getOpenPRs();
            const { parent, children } = computeRelations(prs, current);
            const parentStr = parent ? `#${parent.number}` : current.base;
            const nextStr = children.length ? children.map(c => `#${c.number}`).join(', ') : '(topo)';
            const chainStr = buildChain(prs, current);

            const begin = '<!-- stack-section:begin -->';
            const end = '<!-- stack-section:end -->';

            let body = pr.body || '';
            // sanitize literal \n sequences to real newlines
            body = body.replace(/\\r\\n/g, '\n').replace(/\\n/g, '\n');
            // Strip existing section by markers
            const beginIdx = body.indexOf(begin);
            const endIdx = body.indexOf(end);
            if (beginIdx !== -1 && endIdx !== -1 && endIdx > beginIdx){
              body = body.slice(0, beginIdx) + body.slice(endIdx + end.length);
            }

            const issues = extractIssueNumbers(pr, body);
            const issuesBlock = issues.length
              ? '\n\n## Issues\n' + issues.map(n => `- Closes #${n}`).join('\n')
              : '';

            const section = `${begin}\n## Pilha\n- Pai: ${parentStr}\n- Pr√≥xima: ${nextStr}\n- Cadeia: ${chainStr}${issuesBlock}\n${end}`;
            const newBody = `${section}\n\n${body.trim()}`.trim() + '\n';

            // Clean title suffix like "(Closes #123, #124)" after we've reflected issues in body
            let newTitle = pr.title || '';
            const closeSuffix = /\s*\((?:Closes|Fixes|Resolves)\s*#[0-9,\s#]+\)\s*$/i;
            newTitle = newTitle.replace(closeSuffix, '').trim();

            if (newTitle !== (pr.title || '')){
              await github.rest.pulls.update({ owner, repo, pull_number: prNumber, title: newTitle });
            }

            if (newBody !== (pr.body || '')){
              await github.rest.issues.update({ owner, repo, issue_number: prNumber, body: newBody });
            }

